/**
 * 堆排序
 * 【条件】
 * 1、完全二叉树，每一行都是完全二叉树，最后一行的节点一定是从左到右依次补全，右节点为 2*i+1，左节点为 2*i, 父节点为 (i-1)/2
 * （所以，堆一般使用 数组 和 树 实现的，一般推荐 数组，树的查找然后再和父交换过程没有数组快）
 * 2、大根堆，每一个子树都是大根堆，每一个节点的值都大于等于其左右子树的值，
 * （每来一个数，根据 i - 1进行比较，大于父节点则进行交换，一直比较无法大于父节点，则会保证每新进入一个节点都是大根堆，此过程叫做 heap insert）
 * （popmax， 返回最大值，并且保证剩余还是大根堆，那么此时要进行 heapify，此时需要最大和最低就是末尾元素交换，拿到最大值，而此时剩余的是个堆，然后从0开始进行向下移动，比较左右两节点，选中最大的交换）
 * （扩容n个数，平均复杂度是多是？ logn，为什么？）
 */