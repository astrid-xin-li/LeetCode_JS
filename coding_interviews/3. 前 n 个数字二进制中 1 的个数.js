// 【TOPIC】: 给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。

/**
 * 从二进制只有 0 和 1 组成
 * 十进制转换成二进制，每向前进一位，则当前是 2 的指数倍, 相当于去求 当前数是由几个 2 的不同指数相加，两个则有两个 1
 * [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1]
 * 0 -> 0 
 * 1 -> 1
 * 2 -> 10
 * 3 -> 11
 * 4 -> 100
 * 5 -> 101
 * 6 -> 110
 * 7 -> 111
 * 8 -> 1000
 * 9 -> 1001
 * 10 -> 1010
 * 11 -> 1011
 * 12 -> 1100
 * 13 -> 1101
 * 14 -> 1110
 * 15 -> 1111
 * 16 -> 10000
 */

/**
 * @param {number} n
 * @return {number[]}
 */
var countBits = function(n) {
    // 定义一个长度为 n+1 的数组，用于记录每个数的有几个二进制 1
    const result = new Array(n+1);
    result[0] = 0;
    var i = 1;
    var index = 0;
    var max = Math.pow(2, index);
    var min = 0;

    // [TIP]: 为了判断一个正整数是不是 22 的整数次幂，可以利用方法一中提到的按位与运算的性质。
    // 如果正整数 yy 是 22 的整数次幂，
    // 则 yy 的二进制表示中只有最高位是 11，
    // 其余都是 00，因此 y~\&~(y-1)=0y & (y−1)=0。
    // 由此可见，正整数 yy 是 22 的整数次幂，当且仅当 y~\&~(y-1)=0y & (y−1)=0。
    while(i <= n) {
        if (i === max) {
            result[i] = 1;
            // 向前又进一位了
            index ++;
            min = i;
            max = Math.pow(2, index);
        } else {
            const different = i - min;
            result[i] = 1 + result[different];
        }
        i ++;
    }
    return result;
};


// 示例 1:
// 输入: n = 2
// 输出: [0,1,1]
// 解释: 
// 0 --> 0
// 1 --> 1
// 2 --> 10
// 示例 2:
// 输入: n = 5
// 输出: [0,1,1,2,1,2]
// 解释:
// 0 --> 0
// 1 --> 1
// 2 --> 10
// 3 --> 11
// 4 --> 100
// 5 --> 101
// 0 <= n <= 10^5
